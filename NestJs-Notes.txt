				Nest - Nestjs
.....................................................................................
What is Nest? Nest.js?
  Nest is server side javascript framework for building distributed scalable,efficient server side apps.
 Nest js has been built on the top of "javascript/Typescript" and Node.js
 Nest combines many programming models like object oriented, functional programming,
 Reactive Programming.

Nest Architecture:

                 Nest Application
		       |
	         Express or fastify
			|
		  Node HTTP Module
	 -------------------------------------------			
		     Node.js

Why Nest? 
  Nest Provides lot of Design patterns and implemenations for building enterprise grade server side apps.

Design Patterns and implementations used in Nest

1.MVC
2.IOC / Dependency injections
3.Modular patterns
4.Typescript advanced features
  like decorators
5.Reactive Programming using rxjs for advanced async and streaming apps.

		Angular framework is refactored/rebranded for server side
				Nest
		 Nest follows Angular framework Philosophy
..................................................................................
			 How to start Nest apps
...................................................................................

Nest CLI
  It is command line interface tool that helps to

 =>initialize /create new project
 =>dev features like hot reloading, bundling for testing
 =>schematic features to create artifacts -  code generation.
 =>To create production builds
 =>To test apps including unit testing,etoe testing..

How to install nest cli?

npm install -g @nestjs/cli

like angular cli
npm install -g @angular/cli  

How to verify?
>nest --help

nest --help
Usage: nest <command> [options]

Options:
  -v, --version                                   Output the current version.
  -h, --help                                      Output usage information.

Commands:
  new|n [options] [name]                          Generate Nest application.
  build [options] [app]                           Build Nest application.
  start [options] [app]                           Run Nest application.
  info|i                                          Display Nest project details.
  add [options] <library>                         Adds support for an external library to your project.
  generate|g [options] <schematic> [name] [path]  Generate a Nest element.
    Schematics available on @nestjs/schematics collection:
      ┌───────────────┬─────────────┬──────────────────────────────────────────────┐
      │ name          │ alias       │ description                                  │
      │ application   │ application │ Generate a new application workspace         │
      │ class         │ cl          │ Generate a new class                         │
      │ configuration │ config      │ Generate a CLI configuration file            │
      │ controller    │ co          │ Generate a controller declaration            │
      │ decorator     │ d           │ Generate a custom decorator                  │
      │ filter        │ f           │ Generate a filter declaration                │
      │ gateway       │ ga          │ Generate a gateway declaration               │
      │ guard         │ gu          │ Generate a guard declaration                 │
      │ interceptor   │ itc         │ Generate an interceptor declaration          │
      │ interface     │ itf         │ Generate an interface                        │
      │ middleware    │ mi          │ Generate a middleware declaration            │
      │ module        │ mo          │ Generate a module declaration                │
      │ pipe          │ pi          │ Generate a pipe declaration                  │
      │ provider      │ pr          │ Generate a provider declaration              │
      │ resolver      │ r           │ Generate a GraphQL resolver declaration      │
      │ service       │ s           │ Generate a service declaration               │
      │ library       │ lib         │ Generate a new library within a monorepo     │
      │ sub-app       │ app         │ Generate a new application within a monorepo │
      │ resource      │ res         │ Generate a new CRUD resource                 │
      └───────────────┴─────────────┴──────────────────────────────────────────────┘

How to create new Project?

>nest new my-nest-app


>cd my-nest-app
my-nest-app> code .

Project Structure:
  It has lot of files and folders.

readMe.md
  How to use this project

package.json
  gives information about this project like 
 
 -basic scripts - run,build,test
 -Dependency - basic default dependency for the project.

Basic nest dependency:

dev + prod
 @nest/common
 @nest/core
 @nestjs/platform-express
 rxjs

What is @?
  private package
what is nest?
  nest folder
what is common or core 
 subfolder

nest-cli.json
  provides information /configuration about the project.

node_modules
   -provides all basic libs and apis

src
  ->root application folder
 files
   -main.ts
   -app.module.ts
   -app.controller.ts
   -app.contoller.spec.ts
   -app.service.ts

test
  -contains etoe test configurations
....................................................................................

How to start app?

There are three mode

1.dev mode
2.dev mode with watch
3.prod mode

# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
....................................................................................
			 Nest Application Arch : Work Flow
....................................................................................

Nest Core Concepts:

1.Nest Modularity
  Nest Application by default highly modular.
Nest has two modularity:
1.ES 6 Modularity -Physical
    Code is shared across the application with files and folders
2.Nest Modules - Logical Modularity 
    Objects are organized into another objects

2.Nest is Object oriented framework with ts
   In Nest every thing is Object.

Nest Objects can be classified into two category

1.Infrastructure object
 -Module 
 -Controllers
 -Services and Providers
 -Pipes
 -Guards
2.Domain objects
  Objects which represents data called as models/entity.
  Domain objects are mostly javascript literal objects

Note:
   In Nest you dont need to create infraobjects,Nest will create for us through
  "IoC container"

3.Decorators
   Nest provides lot of built in decorators for building loosly coupled applications
  

4.Nest powered with async programming models

   Nest provides promises with async .. await compatiable
   Nest provides rxjs for data handling  

...................................................................................
				Nest App Types
....................................................................................

Types of Apps:
 Nest is not created for only type of server app.

Web:
1.1.WebServices
    RESTFull Web Services
1.2.Dynamic web apps
    Web app with templates - like php,jsp,aspx...
2.Micro Services
3.Standalone apps
.....................................................................................
			    Nest Application Object

Every Nest app is encapsulated inside Nest Application.
Every Nest app has entry point called "main" program.

in order to create Nest Application object 
 NestFactory to create an application instance, by passing RootModule

main.ts

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  //return Express container/Express app Object
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();


app.module.ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

app.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
...................................................................................
			 Arch of Controller


Steps

1.declare class
class AppController {}

2.Infra Objects are Identified by Decorators
 @Controller  -Controller
 @Module -  SubModule /Main Module 
 @Injectable - Services

import { Controller } from "@nestjs/common";
@Controller()
class AppController {
  
}
 
3.share this class outside-You have to use ES 6 module export statement

import { Controller } from "@nestjs/common";

@Controller()
export class AppController {

}
 
4.Expose end point
  import { Controller, Get } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  getHello(): string {
    return 'Hello Nest App!';
  }
}
...................................................................................
			 Nest Modules
...............................................................................

1.Nest Module is Object 
2.Nest Module Object is used to organize the objects/resources
3.Nest Module Object helps to create other objects like controllers,services,other submodules...
4.Nest Module gives configuration information to the "Nest IoC Container" for object creation
5.Every Nest Application must have one single "App Module" Object
6.We can create many submodules
7.Nest Modules are identified by @Module Decorator.

Steps:

1.Declare class
class AppModule{ }
2.Decorate with @Module
import { Module } from "@nestjs/common";

@Module()
class AppModule { }
3.Decorator takes args called Decorator Meta Data

Decorator Meta Data takes configuration which is information for "Nest" IoC container.

imports:[]
   -All submodules like usermodule,product module
controllers:
   -List of controllers part of this module
providers:
   -List of services to be created
exports :
   -Any Services are part of this module, will not be available to other Modules   
    we need to make sharable service
    list of services to be available to other services / controllers

import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";

@Module({
  imports: [],
  controllers: [AppController]
})
export class AppModule { }
.....................................................................................

How to write our own Controllers


steps
1.write controller
import { Controller,Get } from '@nest/common'


//takes parameter ; url
@Controller("greet")
export class GreetingController {

    @Get()
    public sayGreet():string {
        return 'Greet Me'
    }
}

2.Depedency Configuration
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { GreetingController } from "./greet.controller";

@Module({
  imports: [],
  controllers: [AppController, GreetingController]
})
export class AppModule { }
...................................................................................
			How to structure Nest Application
....................................................................................

Nest Application must be modularizied.

Every Nest application is created based on "features/domain"

A feature module simply organizes the coe relevant for a sepcific feature, keeping
code organized and establilishing clear boundaries.
This helps us manage complexity and develop with "SOLID" principles, as the size of the project/app team grows..

products,cutstomers,payments,....
common/util

1.plan physical modularity

-src - root folder

You have to create sub folder which represents domain /feature

src
|
heroes
  |
   hero.controller
   hero.service
   hero.module
villains
  villain.controller
  villain.service
  villain.module

shared
 shared.module.ts
 filter-text.service.ts


2.plan Logical  modularity

=>For each domain, we must have logical modularity - sub module

heroes
   hero
   hero-list
   shared
   heroes.module.ts

All controllers and services related to that domain, must be injected into that submodule only, not inside main/app module.

rootFolder - src
   Must contain only root module and root Controller

eg:

steps
1.create greeter folder
src/greeter

2.create greeter.module
src/greeter/greeter.module.ts
import { Module } from "@nestjs/common";
@Module({
    imports: [],
    controllers: [],
    providers:[]
})
export class GreeterModule { }

3.create greeter controller
src/greeter/greeter.controller.ts
import { Controller,Get } from '@nestjs/common'
//takes parameter ; url
@Controller("greet")
export class GreetingController {

    @Get()
    public sayGreet():string {
        return 'Greet Me'
    }
}

4.Do depedency configuration

import { Module } from "@nestjs/common";
import { GreetingController } from "./greeter.controller";

@Module({
    imports: [],
    controllers: [GreetingController],
    providers:[]
})
export class GreeterModule { }

app.module.ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { GreeterModule } from "./greeter/greeter.module";

@Module({
  imports: [GreeterModule],
  controllers: [AppController]
})
export class AppModule { }

.....................................................................................
			Style Guide For Nest Apps
.....................................................................................

File structure conventions:

->file must follow the domain model.
   greet
   user
   product
   customer
->file name must follow like
  domainname.infraname.ts
  greet.module.ts
  greet.controller.ts
  greet.service.ts
  greet.controller.spec.ts

->class Names
   ->Noun Customer,Product,Greeter
   ->It has to end With infra Objects
     CustomerModule
     CustomerController
     CustomerService
->root files
   app.controller|module|service
if you have any dto/models and interfaces
  
 src
  |
   heroes
     |
     dto
       | 
       hero.dto.ts
    interfaces
       hero.interface.ts
.....................................................................................
			   Automation-Code Generation
.....................................................................................

Steps we have followed:

1.created folder
2.created files like modules/controllers
3.depedency injection
It is complex step, in order to avoid this steps manually nest offers a cli command

nest generate
   
 generate|g [options] <schematic> [name] [path]  Generate a Nest element.

options:
  -d, --dry-run                      Report actions that would be taken without writing out results.
  -p, --project [project]            Project in which to generate files.
  --flat                             Enforce flat structure of generated element.
  --no-flat                          Enforce that directories are generated.
  --spec                             Enforce spec files generation. (default: true)
  --skip-import                      Skip importing (default: false)
  --no-spec                          Disable spec files generation.
  -c, --collection [collectionName]  Schematics collection to use.
  -h, --help                         Output usage information.




eg:
nest g mo users
CREATE src/users/users.module.ts (82 bytes)
UPDATE src/app.module.ts (313 bytes)

src/users/users.module.ts
import { Module } from '@nestjs/common';

@Module({})
export class UsersModule {}

src/app.module.tsimport { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { GreeterModule } from "./greeter/greeter.module";
import { UsersModule } from './users/users.module';

@Module({
  imports: [GreeterModule, UsersModule],
  controllers: [AppController]
})
export class AppModule { }

...
How to generate controller
nest g co users/user --flat
CREATE src/users/user.controller.ts (97 bytes)
CREATE src/users/user.controller.spec.ts (478 bytes)
UPDATE src/users/users.module.ts (167 bytes)

import { Controller,Get } from '@nestjs/common';

@Controller('user')
export class UserController {

    @Get()
    public getAllUsers():string {
        return 'Users'
    }
}
import { Module } from '@nestjs/common';
import { UserController } from './user.controller';

@Module({
  controllers: [UserController]
})
export class UsersModule {}
..................................................................................
				Controllers
..................................................................................

Controllers are responsible for handling incoming requests and returning responses to the client.
                                  -----------Controller
				  |----------Controller
				  |----------Controller
 Client-------http--request-------|----------Controller
				  |----------Controller

Routing:
  A controller purpose is to received spefic requests for the application, where routing mechanism controls which controller receives which requests.
 A Controller can have more than one route, each route has been designed for different actions.

Routing Syntax:

 The controller starts with root route
 @Controller("customers")   = /customers

 Method level router
 @Get() => /customers
 @Get("list") => /customers/list


Client Testing tool:

1.postman


import { Controller,Get } from '@nestjs/common';

@Controller('users')
export class UserController {

    @Get()
    public findAll():string {
        return 'Users'
    }
    //
    @Get("list")
    public listAll():string {
        return 'user list'
    }
}
localhost:3000/users/list
.....................................................................................
			 Status Code,Headers,Responses
...................................................................................

Status Code :
   By default Nest returns status code based on http operations
 Get - 200
 Post -201
if you want to change the status, you can use @HttpCode decorator.

import { Controller,Get, HttpCode } from '@nestjs/common';

@Controller('users')
export class UserController {

    @Get()
    @HttpCode(200)
    public findAll():string {
        return 'Users'
    }
    //
    @Get("list")
    public listAll():string {
        return 'user list'
    }
}
.....................................................................................					Headers

Nests sends default headers automatically.
x-Powered-By:express  -  the underlying web container of nest 
content-type - the type of value we return
 based on data type , the contenttype would be changed
etc...

What if i want to send headers?

it can be custome header, or built in header.

We have @Header decorator
    @Get()
    @HttpCode(200)
    @Header("secret","abc#239a")
    public findAll(): string {
        return 'Users'
    }
.....................................................................................
				Response types
.....................................................................................

Nest automatically parses the content based on the return type
 Primitives -  string 
  default would be 
      content-type text/html; charset=utf-8

  Object
     if you send object, nest converts into json, adds header 
   application/json

How to return object?

    @Get("user")
    public findUser(): any {
        return {
            id: 1,
            name: 'Subramanian'
        }
    }
Here return type is any, we need to change the return type.

users/user.type.ts

export class User {
    id: number
    name: string
}

 @Get("user")
 public findUser(): User {
        return {
            id: 1,
            name: 'Subramanian'
        }
  }		

How to return array of users?
    @Get("list")
    public listAll(): Array<User> {
        return [
            {
                id: 1,
                name: 'Subramanian'
            },
            {
                id: 2,
                name: 'Ram'
            },
            {
                id: 3,
                name: 'Arun'
            }
        ]
    }
.....................................................................................
				
Response conversion logic is now is nutural way ,Nest interally uses either express or fastify framework.

By default nest uses express as web container, in future if you change from express to fastify, you dont need to change the code.

Coding style:
  Platform nutural code
  Lib-Specific code - express


Express way of returning code:
  //express way of returning response
    @Get("express")
    public findAllUsingExpress(@Res() response) {
        return response.status(200).json({ id: 1, name: 'something' })
    }
....................................................................................
			 Request
....................................................................................
Handlers access request details, Nest provides access to the request object of the underlying platform(Express by default).
We can access request object details by injecting @Req() decorator to the handler signature


import {
  Req,
} from '@nestjs/common';
import { Request } from 'express';

  @Get('input')
  public getUserDetail(@Req() request: Request): string {
    console.log(request)
    return 'user input';
  }


What are the details releated to request object?
 Query Strings
 Path Parameters
 Http Headers
 Body

Nest provides decorators to access specific details - Platform nutural code
Query String -@Query
Path Params  -@Param
Headers      -@Headers
Body         -@Body
...
Host          -@HostParam
Ip            -@Ip()


Nest provides request object to access specific details - Express spcific
Query String - req.query
Path Params  - req.params
Headers      - req.headers
Body         - req.body

Host         - req.hosts
ip            -req.ip

  //handles request details
  @Get('reqdetails1')
  public getRequestDetails1(@Req() request: Request): string {
    console.log(`ip ${request.ip}`)
    console.log(`host ${request.host}`)
    console.log(request.headers)
     
    return 'request details 1';
  }
  @Get('reqdetails2')
  public getRequestDetails2(@Headers() headers,@Ip() ip): string {
    console.log(headers)     
    console.log(ip)
    return 'request details 2';
  }
...................................................................................
			        Dynamic route - Route Parameters
...................................................................................

if you want to read dynamic data as part of request
for eg:

GET /users/1 /users/2  /users/3


import {
  Param,

} from '@nestjs/common';
import { User } from './user.type';
import { Request } from 'express';
  //dynamic parameters
  @Get(':id')
  public getUserById(@Param() params): string {
    console.log(params);
    return 'user by id';
  }
...................................................................................					Query params

if you want to send Query params

    //GET  /users/1?sort=asc;location=xxx
    @Get('query')
    public filterUsers(@Query() queryparams): string {
        console.log(queryparams);
        return 'query params';
    }

Req:
GET users/query?a=10&b=23
.....................................................................................
			How to handle request body
....................................................................................

Client can send data to the server in many ways

1.via URL 
   Path Params  /resource/value
   Query params /resource?a=10&b=30
2.Via body of the Protocal - payload

@Body - reads data
req.body -reads data

Action method
@Post

Steps:

1.
@Post("create")
public create(){
   return "user created"
}

2.read payload
 @Post("create")
  public create(@Body() payload){
        console.log(payload)
        return "user created"
    }
}

3.if you are using ts, you need to create type for incoming payload
 DTO - Data transfer object

A DTO is an object that defines how the data will be sent over the network.
We can define DTO schema by using ts interface,class or type keyword.
Nest recommends only classes because classes are part of es 6 standard, suppose if later if you want to migrate code to js stack it will not be any issues

src/users/create-user.dto.ts

export class CreateUserDto {
    id: number;
    name: string;
    age: number;
    status: boolean
}
  //read body
    @Post("create")
    public create(@Body() createUserDto: CreateUserDto) {
        console.log(createUserDto)
        return "user created"
    }


Full code:
import {
    Controller,
    Get,
    HttpCode,
    Header,
    Headers,
    Res,
    Ip,
    Param,
    Query,
    Post,
    Req,
    Body
} from '@nestjs/common';
import { User } from './user.type';
import { Request } from 'express';
import { CreateUserDto } from './create-user.dto';

@Controller('users')
export class UserController {
    @Get()
    @HttpCode(200)
    @Header('secret', 'abc#239a')
    public findAll(): string {
        return 'Users';
    }

    @Get('user')
    public findUser(): User {
        return {
            id: 1,
            name: 'Subramanian',
        };
    }

    //express way of returning response
    @Get('express')
    public findAllUsingExpress(@Res() response) {
        return response.status(200).json({ id: 1, name: 'something' });
    }

    //GET  /users/1?sort=asc;location=xxx
    @Get('query')
    public filterUsers(@Query() queryparams): string {
        console.log(queryparams);
        return 'query params';
    }

    //dynamic parameters

    @Get(':id')
    public getUserById(@Param() params): string {
        console.log(params);
        return 'user by id';
    }

    //handles request details
    @Get('reqdetails1')
    public getRequestDetails1(@Req() request: Request): string {
        console.log(`ip ${request.ip}`);
        console.log(`host ${request.host}`);
        console.log(request.headers);

        return 'request details 1';
    }
    @Get('reqdetails2')
    public getRequestDetails2(@Headers() headers, @Ip() ip): string {
        console.log(headers);
        console.log(ip);
        return 'request details 2';
    }
    //
    @Get('list')
    public listAll(): Array<User> {
        return [
            {
                id: 1,
                name: 'Subramanian',
            },
            {
                id: 2,
                name: 'Ram',
            },
            {
                id: 3,
                name: 'Arun',
            },
        ];
    }

    //read body
    @Post("create")
    public create(@Body() createUserDto: CreateUserDto) {
        console.log(payload)
        return "user created"
    }
}
.....................................................................................
			  CURD
....................................................................................
Create -  POST
Update -  PUT
Read(GET) - @GET
Delete   - @Delete

import {
  Controller,
  Get,
  Query,
  Put,
  Delete,
  Param,
  Body,
  Post,
} from '@nestjs/common';
import { CreateUserDto } from './create-user.dto';

@Controller('users')
export class UserController {
  //create
  @Post()
  create(@Body() createUserDto: CreateUserDto): string {
    return 'This action adds a new User';
  }
  //Query
  @Get()
  findAll(@Query() query) {
    return 'This action user with query';
  }
  @Get(':id')
  findOne(@Param('id') param) {
    return 'This action returns one user';
  }
  @Put(':id')
  update(@Param('id') param, @Body() updateUserDto) {
    return 'This action update users';
  }
  @Delete(':id')
  remove(@Param('id') param) {
    return 'This action removes user';
  }
}
...................................................................................
			CURD automation

if you want to write CURD operations using cli,

 nest g resource users
? What transport layer do you use? REST API
? Would you like to generate CRUD entry points? Yes
CREATE src/users/users.controller.ts (894 bytes)
CREATE src/users/users.controller.spec.ts (566 bytes)
CREATE src/users/users.module.ts (247 bytes)
CREATE src/users/users.service.ts (609 bytes)
CREATE src/users/users.service.spec.ts (453 bytes)
CREATE src/users/dto/create-user.dto.ts (30 bytes)
CREATE src/users/dto/update-user.dto.ts (169 bytes)
CREATE src/users/entities/user.entity.ts (21 bytes)
UPDATE src/app.module.ts (313 bytes)

Without CURD generator:

1.You have to generate module
2.You have to create controller
3.You have to create service
4.you have to DTO objects
5.You have to create Entity class for db 
6.Proper configuration and dependency injection


With CURD generator you can generate boiler plat code , then you can start editing code.
................................................................................				Asynchronicity -Async Respsonse
..................................................................................

By default node is async,so we can send responses asyncly.

if you talk to database, it may delay...

Styles of async programming:
1.callbacks
2.Promises 
3.Promises with async and await
4.Rxjs


sync
 
It returns always string,objects,arrays

async 
api returns Promise /rxjs types
...
import { Controller, Get } from '@nestjs/common';

@Controller('asyncapi')
export class AsyncController {
  // @Get()
  // getAsyncResponse(): Promise<string> {
  //     //return Promise.resolve('Hello')
  //     return new Promise((resolve, reject) => {
  //         setTimeout(resolve, 5000, 'Hello Promise')
  //     })
  // }

  @Get()
  async getAsyncResponse(): Promise<string> {
    return 'Hello async fun'; // Promise.resolve('Hello)
  }
  // @Get()
  // getAsyncResponse(): Promise<any[]> {
  //     //return Promise.resolve('Hello')
  //     return new Promise((resolve, reject) => {
  //         setTimeout(resolve, 5000, [{ message: 'Hello Promise' }, { message: 'Hai Promise' }])
  //     })
  // }
  @Get('sync')
  getSyncResponse(): string {
    return 'Sync';
  }
}
.....................................................................................
			Depedency Injection-Services,Providers
.....................................................................................

Injecting Object references into another Object, so that we can call another object apis.
Provider means it provides some features to objects
All Providers  are simple classes
 could be 
   services
   repositories
   facatories
   helpers

Why Providers?
  Providers main idea is it can be injected as a dependency.

How nest runtime creates instance of providers?

In any Nest module , you can configure

 providers: [UserService]

All Provider classes are identified by the decorator
     "@Injectable"

Steps:

1.declare Service class(Provider)


export class GreeterService {
    
}

2.decorate with Injectable decorator

import {Injectable} from '@nestjs/common'

@Injectable()
export class GreeterService {

}

3.write biz logic
import { Injectable } from '@nestjs/common';

@Injectable()
export class GreeterService {
    private readonly message: string = 'Greeter Service';
    constructor() { }

    //Biz methods
    public async sayGreet(): Promise<string> {
        return this.message;
    }
}

4.Inject - Provider configuration
import { Module } from "@nestjs/common";
import { GreetingController } from "./greeter.controller";
import { GreeterService } from "./greeter.service";

@Module({
    imports: [],
    controllers: [GreetingController],
    providers:[GreeterService]
})
export class GreeterModule { }

5.Depedency Injection
 Grab the created instance into another object(controller)
Nest supports only constructor dependency, so that we have to inject into constructor only.

import { Controller, Get } from '@nestjs/common'
import { GreeterService } from './greeter.service'
//takes parameter ; url
@Controller("greet")
export class GreetingController {

    constructor(private greeterService: GreeterService) { }

    @Get()
    public sayGreet(): Promise<string> {
        return this.greeterService.sayGreet()
    }
}
.....................................................................................
			Middlewares
.....................................................................................

What is Middleware?
  Middleware is a function which is called before the route handler.
  Middlewares are used to preprocess the request.
  Since Middleware is function which can process "request and response"

Express sytax
router.get("/url",function(req,res,next){}
or
app.get("/url",function(req,req,next){})

The difference between request handler and middlewares are middlewares have third parameter called "next".
 The value of next is function reference.

you can have more than one middlewares too.

How to write middlewares in nest?

every middleware is a class which is injectable.

import { Injectable, NestMiddleware } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

@Injectable()
export class LoggerMiddleware implements NestMiddleware {

    use(req: Request, res: Response, next: NextFunction) {
        //any pre processing code 
        console.log("Request....")
        next() // moves controller to next middleware or controller
    }
}

Configure Middlewares and Dependency Injection :


In the Main Module

In the App Module we need to implments NestModule interface

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { AsyncController } from './app.asynccontroller';
import { AppController } from './app.controller';
import { GreeterModule } from './greeter/greeter.module';
import { LoggerMiddleware } from './logger.middleware';
import { UsersModule } from './users/users.module';

@Module({
  imports: [GreeterModule, UsersModule],
  controllers: [AppController, AsyncController],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes('/');
  }
}

Multiple urls:
consumer.apply(LoggerMiddleware).forRoutes({path:'user',method:RequestMethod.ALL},);


consumer.apply(LoggerMiddleware).forRoutes({path:'user',method:RequestMethod.GET});
consumer.apply(LoggerMiddleware).forRoutes({path:'user',method:RequestMethod.PUT});

exclude:
  Method which excludes the middleware code to applied

 consumer.apply(LoggerMiddleware)
   .exclude({path:'remove',RequestMethod.DELETE})
   .forRoutes('/');

There are two ways of writing middlewares:

1.class middleware - es6 and ts synatx
2.functional middleware 
   

Nest even support functional functional

import { Request, Response, NextFunction } from "express";
export function logger(req: Request, res: Response, next: NextFunction) {
    console.log("Function Logger ...")
    next()
}

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { AsyncController } from './app.asynccontroller';
import { AppController } from './app.controller';
import { GreeterModule } from './greeter/greeter.module';
// import { LoggerMiddleware } from './logger.middleware';
import { logger } from './loggerfun.middleware'
import { UsersModule } from './users/users.module';

@Module({
  imports: [GreeterModule, UsersModule],
  controllers: [AppController, AsyncController],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    //consumer.apply(LoggerMiddleware).forRoutes('/');
    //consumer.apply(logger).forRoutes("/")
    consumer.apply(logger).forRoutes(AppController)
  }
}
....................................................................................
How to multiple middlewares for a given route/ controller?

logger.middleware.ts
import { Request, Response, NextFunction } from "express";

export function logger(req: Request, res: Response, next: NextFunction) {
    console.log("Function Logger ...")
    next()
}

greeting.middleware.ts

import { Request, Response, NextFunction } from "express";

export function greetMiddleware(req: Request, res: Response, next: NextFunction) {
    console.log("welcome (Greeting Middlware)")
    next()
}


app.module.ts
@Module({
  imports: [GreeterModule, UsersModule],
  controllers: [AppController, AsyncController],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
   //applying mutiple middlewares
    consumer.apply(logger, greetMiddleware).forRoutes(AppController);
  }
}
..................................................................................
			   Global Middlewares

if you want to apply middlewares for every request and every method in the application -  Global Middlewares

Global Middlewares are registeried in the main that means application object.
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { logger } from './loggerfun.middleware';

async function bootstrap() {
  //return Express container/Express app Object
  const app = await NestFactory.create(AppModule);
  //register global middlewares
  app.use(logger);

  await app.listen(3000);
}
bootstrap();
....................................................................................
			  Exception Handling
...................................................................................

Nest comes with a builtin exception layer which is responsible for processing all unhandled expceptions across the application.
When an exception is handled by app code, it is caught by this layer which automatically sends an appropriate user-friendly response.

Out of the Box, Nest handles exception by built in "Global Exception filter(middleware)".
Which handles exceptions of type "HttpException".

Error Response:

 {
  "statusCode" : 500,
  "message" : "Internal Server Error" 
 }

How to throw an exception manually?

 @Get("error")
    public sayHello() {
       // return "Error"
       throw new HttpException("something went wrong",HttpStatus.FORBIDDEN)
    }

if you run this code, you will get response like below

GET /greet/error

{
    "statusCode": 403,
    "message": "something went wrong"
}
...

eg:
import { Injectable,Scope  } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class GreeterService {
    private readonly message: string = 'Greeter Service';
    constructor() { 
        console.log('Greeter service is called')
    }

    //Biz methods
    public async sayGreet(): Promise<string> {
        return this.message;
    }

    public async sayHello(): Promise<string> {
        //return "Hello"
       return Promise.reject("something went wrong")
    }
}

controller:

import { Controller, Get, HttpException, HttpStatus } from '@nestjs/common';
import { GreeterService } from './greeter.service';
//takes parameter ; url
@Controller('greet')
export class GreetingController {
    constructor(private greeterService: GreeterService) { }

    @Get()
    public sayGreet(): Promise<string> {
        return this.greeterService.sayGreet();
    }
    @Get('error')
    public async sayHello() {
        try {
            return await this.greeterService.sayHello();
        } catch (err) {
            throw new HttpException({
                status: HttpStatus.FORBIDDEN,
                error: err.message,
            }, HttpStatus.FORBIDDEN, { cause: err });
        }
    }
}
..............................................................................
			 How to handle custom Exception
..................................................................................

Write a Custom Exception


import { HttpException, HttpStatus } from "@nestjs/common";


import { HttpException, HttpStatus } from "@nestjs/common";


export class GreeterException extends HttpException {
    constructor(message:string='Greeter Exception') {
        super(message, HttpStatus.BAD_REQUEST)
    }
}

How to use that Exception?
import { Controller, Get, HttpException, HttpStatus } from '@nestjs/common';
import { GreeterException } from './greeter.exception';
import { GreeterService } from './greeter.service';

@Controller('greet')
export class GreetingController {

    //custom exception
    @Get("customerr")
    public sayHai(){
        throw new GreeterException("Hai went wrong")
    }

}
.....................................................................................	
				Pipes
.....................................................................................

What is Pipe?
  A Pipe is object decorated with "@Injectable" which implements PipeTranform Interface.

Use cases of Pipe:
1.Transformation : transform input data to the desired eg string to integer,
2.Validation: evaluates the input data and if valid, simply pass it through unchanged, other wise throws an exception when input data is invalid.

Pipes working pattern/flow:
Pipes are called just before Controller methods are called.

Pipes receives the arughments destined for the method and operates on them.
Any transformation and validation takes place at that time , after which the route handler is invoked with any transformed arugments.

Nest provides lot of built in pipes that yo can use out of the box.

Built in pipes:
1.ValidationPipe
2.ParseIntPipe
3.ParseFloatPipe
etc..

How to use/bind pipe with Routers?

ParseIntPipe

eg/:

  @Get(":id")
  findOne(@Param("id", ParseIntPipe) id: number) {
    return id
  }

Here if any input with string with value is numbers , strings are converted into numbers and display the output.

GET /100

response 
 10

GET /abc

response
{
    "statusCode": 400,
    "message": "Validation failed (numeric string is expected)",
    "error": "Bad Request"
}
...................................................................................
				Custom Pipes
...................................................................................
what if  i want to write our own pipes?

Pipes are classes with @Injectable 

import { ArgumentMetadata, PipeTransform } from "@nestjs/common";

import { ArgumentMetadata, Injectable, PipeTransform } from "@nestjs/common";


@Injectable()
export class ValidationPipe implements PipeTransform {
    transform(value: any, metadata: ArgumentMetadata) {
         return parseInt(value)
    }
}

value : parameter is the currently process method argument
metadata: is currently processed method args's meta data.

export interface ArgumentMetadata {
 type: 'body' | 'query'| 'param' | 'custom',
 metatype?: T<unknown>
 data?:string
}


import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
import { ValidationPipe } from './validation.pipe';

@Controller()
export class AppController {
  //custom in pipes
  @Get(":id")
  findOne(@Param("id", ValidationPipe) id: number) {
    return id
  }
}
...............................................................................
			Service layer and Databases
...............................................................................

Nest is database independant, allowing you to easily integrate with any SQL and NOSQL database.
Connecting to databse in nest is simple a matter of loading appropriate Node.js database drivers fr the database.
.....................................................................................	
			  Node.js based ORM frameworks

Node.js(Nest) can integrate with any ORM frameworks.

Types of Node.js and typescript based ORMS

1.MikroORM
2.Sequelize	
3.TypeORM
4.Knex.js
5.Prisma		

NoSql - Mongodb
1.mongoose
.....................................................................................
				
We are going to learn
SQL database
1.PostgreSQL /Mysql
2.Sequelize ORM

Steps :

1. we need to start database.

src
 |
 docker-compose.yml
    version: "3"
services:
  mysql:
    image: mysql:8
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: test
    ports:
      - "3307:3307"

Through docker
\nestdbapp>docker-compose up


2.install all database dependencies

npm install @nestjs/sequelize sequelize sequelize-typescript mysql2 --save

npm install @types/sequelize 


3.Connecting to database : Configuration of mysql database with Application.

SequalizeModule must be injected into App Module with necessary configuration.
.................................................................................

app.module.ts
import { AppService } from './app.service';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user/entities/User.model';
import { UserModule } from './user/user.module';

@Module({
  imports: [
    SequelizeModule.forRoot({
      dialect: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      autoLoadModels: true,
      synchronize: true,
    }),
    UserModule,
  ],
  controllers: [AppController],
  providers: [AppService]
})
export class AppModule { }



Once the above configuration over, The Sequelize Service Object will be available across the application without needing to import any module.


Sequelize Service Object can be injected into other Service Object or into controller
.

eg:

@Injectable()
export class ProductService{ 
  constructor(private sequelize:Squelize){}

  findAll(){ 
    this.sequelize.findAll()
  }
}
.....................................................................................
			 Entites /Models
...................................................................................

What is Enity/Model?
  Object which is persistable into database.

Design patterns for ORM programming:

1.Active Record Pattern
2.Repository Pattern

Mostly we use Repository Pattern.

How repository works?

1.declare entity

@Table
@Enity
class  User {
   @Coulmn
   id
   
}
2.write repository class

class UserRepository extends CurdRepository<User>{

    //curd apis
}


1.Active Record Pattern

Steps 
1.Declare Entity and that entity going to act as Repository Itself..
@Table
@Enity
class  User extends Model {
   @Coulmn
   id
   
}

Sequelize implements "Active Record Pattern" - You can use the model classes directly to interact with the database.

src/users/entities/user.model.ts

import { Table, Column,Model } from 'sequelize-typescript'

@Table
export class User extends Model {
    //column mapping
    @Column
    firstName: string

    @Column
    lastName: string

    @Column({ defaultValue: true })
    isActive: boolean

}
}
.....................................................................................

Full Example

Steps:

1.Model declaration with Active Record Pattern

import { Table, Column,Model } from 'sequelize-typescript'

@Table
export class User extends Model {
    //column mapping
    @Column
    firstName: string

    @Column
    lastName: string

    @Column({ defaultValue: true })
    isActive: boolean

}

2.Service layer
user/services

user.service.ts

import { Injectable } from '@nestjs/common'
import { InjectModel } from '@nestjs/sequelize'
import { User } from '../entities/User.model'

@Injectable()
export class UserService {
    //inject model , since it is acting as repospository
    constructor(
        @InjectModel(User)
        private readonly userModel: typeof User,
      ) {
          console.log('user service is called')
      }
    //apis 
    async findAll():Promise<User[]> {
         //curd apis 
         return this.userModel.findAll()
    }
}

Controller

import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { User } from './entities/user.model';
import { UserService } from './services/user.service';

@Controller('users')
export class UserController {
    constructor(private readonly userService: UserService) { }

    @Get()
    findAll(): Promise<User[]> {
        return this.userService.findAll();
    }


}

User Module:

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './entities/user.model';
import { UserController } from './user.controller';
import { UserService } from './services/user.service';

@Module({
    imports: [SequelizeModule.forFeature([User])],
    providers: [UserService],
    controllers: [UserController],
})
export class UserModule { }


App Module:
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user/entities/User.model';
import { UserModule } from './user/user.module';

@Module({
  imports: [
    SequelizeModule.forRoot({
      dialect: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      autoLoadModels: true,
      synchronize: true,
    }),UserModule,
  ],
  controllers: [AppController],
  providers: [AppService]
})
export class AppModule { }

...................................................................................
			 CREATE,Select,Remove,UPDATE


import { Injectable } from '@nestjs/common'
import { InjectModel } from '@nestjs/sequelize'
import { User } from '../entities/User.model'
import { CreateUserDto } from '../dto/create-user.dto'

@Injectable()
export class UserService {
    //inject model , since it is acting as repospository
    constructor(
        @InjectModel(User)
        private readonly userModel: typeof User,
    ) {
        console.log('user service is called')
    }
    //apis 
    async findAll(): Promise<User[]> {
        //curd apis 
        return this.userModel.findAll()
    }

    create(createUserDto: CreateUserDto): Promise<User> {
        return this.userModel.create({
            firstName: createUserDto.firstName,
            lastName: createUserDto.lastName,
        });
    }

    findOne(id: string): Promise<User> {
        return this.userModel.findOne({
            where: {
                id,
            },
        });
    }

    async remove(id: string): Promise<void> {
        const user = await this.findOne(id);
        await user.destroy();
    }
}

Controllers:
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { User } from './entities/user.model';
import { UserService } from './services/user.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('users')
export class UserController {
    constructor(private readonly userService: UserService) { }

    @Get()
    findAll(): Promise<User[]> {
        return this.userService.findAll();
    }
    @Post()
    create(@Body() createUserDto: CreateUserDto): Promise<User> {
      return this.userService.create(createUserDto);
    }


    @Get(':id')
    findOne(@Param('id') id: string): Promise<User> {
      return this.userService.findOne(id);
    }
  
    @Delete(':id')
    remove(@Param('id') id: string): Promise<void> {
      return this.userService.remove(id);
    }

}
For advanced Query Operations
  Follow this doc.
       https://sequelize.org/docs/v6/core-concepts/raw-queries/
....................................................................................
				MicroServices
.....................................................................................
What are microservices?

Microservices - also known as the microservice architecture - is an architectural style that structures an application as a collection of services that are

Highly maintainable and testable
Loosely coupled
Independently deployable
Organized around business capabilities
Owned by a small team


How to break the applications?
  Application is decomposed into smaller application called services

Ecommerce:
  Order -app
  Customer-app
  Invoice -app
  Payments-app
  Delivery -app
.....................................................................................
			  Microservice implmentation
....................................................................................

Nest natively Supports the microservice archtectural style of development.
Nest offers di,decorators,exception filters,pipes, all features are applied for microservice development too.

Where ever nest abstracts implementation details, so that nest allows to communicates apps which may be running different platforms like httpbased,tcp based,websocket....

In Nest, a microservice is fundamentally an application aht uses a different transport layer than HTTP.
Nest offers lot of transport layers, through which we can exchange/transmit messages.
We have many transport layer , the default transport layer is "TCP".

How to transmit/exchange data(message)?

 Nest offers two style of message transportation

1.request-response
2.event-based

Implementation:
Steps:
1.app1
2.app2

Use case:
I am going to build two applications ,Gateway

GateWay is app, which is reponsiable to connect http clients

Client GET /api/something ---------APIGateWay------sendMessage------UserApplication

UserApplication is TCP based Micro service app.

Steps:

1.create UserApplication

1.1
microservices>nest new usermicroservice
1.2
E:\session\IBM\2022\nov\nestapps\microservices>cd usermicroservice

1.3
install microservice packages/depedencies
                 
usermicroservice> npm install --save @nestjs/microservices

1.3. In order convert nest http app into Microservice app, we need to configure main.ts

By default Nest creates httpbased app only

npm start

> usermicroservice@0.0.1 start
> nest start
[Nest] 9840  - 22/11/2022, 9:54:37 am     LOG [NestFactory] Starting Nest application...
[Nest] 9840  - 22/11/2022, 9:54:37 am     LOG [InstanceLoader] AppModule dependencies initialized +33ms
[Nest] 9840  - 22/11/2022, 9:54:37 am     LOG [RoutesResolver] AppController {/}: +6ms
[Nest] 9840  - 22/11/2022, 9:54:37 am     LOG [RouterExplorer] Mapped {/, GET} route +3ms
[Nest] 9840  - 22/11/2022, 9:54:37 am     LOG [NestApplication] Nest application successfully started +3ms
.....................................................................................
NestFactory offers a static method called "createMicroService"

Go to main.ts

 type MicroserviceOptions = GrpcOptions | TcpOptions | RedisOptions | NatsOptions | MqttOptions | RmqOptions | KafkaOptions | CustomStrategy
import MicroserviceOptions

import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
      options: {
        port: 3001,
      },
    },
  );
  await app.listen();
}
bootstrap();
.
>npm start

> usermicroservice@0.0.1 start
> nest start

[Nest] 6668  - 22/11/2022, 10:03:34 am     LOG [NestFactory] Starting Nest application...
[Nest] 6668  - 22/11/2022, 10:03:34 am     LOG [InstanceLoader] AppModule dependencies initialized +31ms
[Nest] 6668  - 22/11/2022, 10:03:34 am     LOG [NestMicroservice] Nest microservice successfully started +22ms
..............................................................................

Patterns (Message/events transmitting pattern):
........................................

Microservices recongnize both messages and events by patterns

What is pattern?
  Pattern is plain string value or literal object.
  Patterns are seralized automaticall and can be sent over the network along with the   data portion of a message.

Actors:
  Sender  is app which transmits events or messages
  Consumer is app which listens for events and message.

Request-Response:
=> It is style which is useful when you need to exchange messages between various external services.
=> We can send message, the receiver receives messages without ack.
=> It is fire and forget model.
=> It is not usefull incase if you stream data using streaming protcals/transporters
   such as kafa,NatsStreaming,rxjs

How Request-Response works?
 To enable request response message type, Nest creates two logical channels

One is for transimiting the data while other waits for incoming responses.
................................................................................
How to send Message via Request-Response and How to listen for Message?

Sender: to be discussed later

Listener

@Controller()
export class Consumer{

  @MessagePattern({cmd:'process'})
  public getMessage(data:any){ 
    //process the incoming data
  }
}

Event-based Pattern:
....................
if you send data in streaming ways, events based would very usefull.
You want to simply notify another service that a certain condition has occured in the part system.

@EventPattern('nameoftheevent')

@Controller()
export class Consumer{

  @MessagePattern({cmd:'process'})
  public getMessage(data:any){ 
    //process the incoming data
  }

  @EventPattern('user_created')
  pulic onUserCreated(user:any){
     //process the events
  }
}

eg:
import { Controller, Get } from '@nestjs/common';
import { MessagePattern, EventPattern } from '@nestjs/microservices';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) { }

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
  //Listener methods : message based and event based
  @MessagePattern({ cmd: 'process' })
  public getData(data: any) {
    console.log(data)
    return data;
  }

  @EventPattern('user_created')
  public onUserCreated(user: any) {
    //biz logic 
    console.log(user)
  }
}
...................................................................................
              		 Client
...................................................................................
The Client Application is application which sends messages and publishes events.

The Client Applications uses "ClientProxy" class used to send and publish events.

ClientProxy has two methods

1. send method - request-response
2. emit method - event publishing

ClientProxy is built in service class which is part of "ClientsModule".

Before using ClientProxy we need to initalize the ClientsModule in the app.module.ts of client code.

@Module({
  imports: [
    ClientsModule.register([{
      name:'USERSERVICE', //token which is used for identififying services inside 			  ctrl/another service
      transport:Transport.TCP,{
        port:3001
      }
    }])
  ]

})

register:
  It is method used to establish connection between two microservices
[]
  It is array of objects representing microservice transportes
{name:'UserService'}
  name property is used as injection token that can be used inside another service/controller

transport:  
  which transporter is used to transmit messages and events
options:
  port: 
   On which port the other microservice is listening on  
Steps:

1.create client app
microservices>nest new gatwaymicroservice
$ cd gatwaymicroservice
microservices\gatwaymicroservice

2.install microservice dependencies
npm install @nestjs/microservices --save


3.Configure Main Module - app.module.ts

import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'USERSERVICE',
        transport: Transport.TCP,
        options: {
          port: 3001
        }
      }
    ]),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule { }
.....................................................................................
			  Send Message
....................................................................................

inside service or controller we need do clientProxy di

constructor(@Inject('USERSERVICE') private client:ClientProxy){}



Event Based:
this.client.emit('user_created',user)

Message Based:
const pattern = {cmd:'process'}
this.client.send(pattern,payload)
			
eg:
import { Controller, Get, Post, Body, Inject } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';
import { AppService } from './app.service';
import { Observable } from 'rxjs';

@Controller()
export class AppController {
  constructor(@Inject('USERSERVICE') private readonly client: ClientProxy) {}

  @Get()
  getHello(): string {
    return 'Hello';
  }
  //event based
  @Post()
  createUser(@Body() createUserRequest: any) {
    // console.log(createUserRequest);
    this.client.emit('user_created', createUserRequest);
    return createUserRequest;
  }

  @Get("message")
  accumulate(): Observable<number> {
    const pattern = { cmd: 'process' };
    const payload = [1, 2, 3];
    return this.client.send<number>(pattern, payload);
  }
}
....................................................................................
				
Case Study:

Microservice

App1 - Will get CURD requests
APP2 - Will receive Message --- Database- MYSQL
.....................................................................................
			Hybrid Microservices
.....................................................................................

What is hybrid microservices?

Microservices either can be pure http or pure tcp based app - inter service communications

Hybrid Microservices is mixed of both "http + tcp".

Steps:

1. nest new hybridmicroservice
2. npm i --save @nestjs/microservices

main.ts
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  // pure microservice configuration
  /**
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
      options: {
        port: 3001,
      },
    },
  );
  await app.listen();
   */
  // Hybrid Application(Microservice) : HTTP + TCP
  const app = await NestFactory.create(AppModule)
  app.connectMicroservice<MicroserviceOptions>({
    transport: Transport.TCP,
  })
  await app.startAllMicroservices()
  await app.listen(3003)
  console.log(`Application is runnning on ${await app.getUrl()}`)
}
bootstrap();
..................................

math.module.ts
import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { MATH_SERVICE } from './math.constants';
import { MathController } from './math.controller';

@Module({
  imports: [
    ClientsModule.register([{ name: MATH_SERVICE, transport: Transport.TCP }])
  ],
  controllers: [MathController],
})
export class MathModule {}

math.controller.ts
import { Controller, Get, Inject } from '@nestjs/common';
import { MATH_SERVICE } from './math.constants';
import { ClientProxy, MessagePattern, EventPattern } from '@nestjs/microservices';
import { Observable, of } from 'rxjs'
@Controller('math')
export class MathController {
  constructor(@Inject(MATH_SERVICE) private readonly client: ClientProxy) { }

  //http controller
  @Get()
  execute() {
    const pattern = { cmd: 'sum' };
    //data
    const numbers = [1, 2, 3, 4, 5];
    //invoke api
    return this.client.send<number>(pattern, numbers);
  }

  @Get('trigger')
  trigger() {
    //data
    const numbers = [1, 2, 3, 4, 5];
    //invoke api
    const res = this.client.emit('sum_trigger', numbers);
    console.log(res)
    //res.subscribe(x => console.log('subscriber',x));
    return 'result'
  }
  //method to be called by message pattern

  @MessagePattern({ cmd: 'sum' })
  public sum(data: number[]) {
    return (data || []).reduce((a, b) => a + b);
  }

  @EventPattern('sum_trigger')
  public onSum(data: number[]): Observable<any> {
    //biz logic 
    console.log('trigger', data)
    const result = (data || []).reduce((a, b) => a + b)
    console.log(result)
    return of(result)
  }
}

math.constants.ts
export const MATH_SERVICE = 'MATH_SERVICE'
.....................................................................................
			MicroService Representations
.....................................................................................
Micro services are represented / Microservices are designed based on communications

1.Remote Procedure Invocation
2.Messaging

RPI Technologies:
1.REST
2.RPC-(gRPC)
3.Apache Thrift


1.REST
  HTTP Based Microservice implementations.
  This is common microservice implementations.
We have implemented REST based Microservices in Nest

2.RPC
   Remote Procedure call,the remote methods are called with help of TCP protcal.
  We have implemented TCP Based Microservices in Nest.

The advanced version of RPI(RPC) -  gRPC
  gRPC is advanced RPI based framework for building inter service communications

............................................................................................. 
 			Internet based RPC/RPI - HTTP Driven RPC
.............................................................................................

WebServices:
 It is a remote program, having api , communicated via http protocal , transfer data

SOAP Based:
 it is similar to legacy rpc but communicated over soap over http,transfer xml based data.

REST: 
 It is also RPC but only works with http, carries multiple data format,json was understood
light models


SOA Architectures:
 based on xml distributed programming
..............................................................................................
				Microservices and API Design
.............................................................................................

1.REST API 
   -easy to use/develop
 -what if my app is using multiple languages
    RPC

Drawbacks of REST/HTTP protocal.

REST arch built on the top of "http 1.1" protocal version.


1.multi request-reponse cycle
   in every req-res - tcp connection is created

2.Headers are plain text which takes lot of space
● HTTP is stateless
	○ Headers are sent in every request
	○ Carries info like Cookie
	○ Plain text - relatively large in size
	○ Can not be compressed

3.Serialization & Deserialization
   since http1.1 send always text, not binary which are speedy.


4.API Contract
   There is no api contract (strongly typed) which makes confussion among applications.

5.Client SDK
   There is no proper client sdk to process http messages.
...................................................................................
				Google and http Protocal
.....................................................................................

Google started a project called SPDY (pronounced "speedy") is a deprecated open-specification communication protocol that was developed primarily at Google for transporting web content.[1] SPDY manipulates HTTP traffic

later spdy was opensourced named "HTTP/2"

SPDY became the basis for HTTP/2 specification

Why?
-tcp multiplxing -  non blocking arch
-Binary
-Header Compression
-Flow Control -Streaming
............................................................................................
			RPC - Framework alternate to REST based design
............................................................................................

Google has  started working on RPC systems more than 15 years from now , for service communicaitons.

Project Name 
Stubby
● RPC Framework from Google
● 15 years
● 10 billions reqs / sec!!!!
● Cross-platform

........................................
● Tightly coupled with infrastructure
............................................................................................
				gRPC 

● Developed at Google
● Inspired by Stubby
● Released in 2016
● Adopted by
	○ Netflix
	○ Microsoft
● Belongs to CNCF
...........................................................................................
				Why gRPC

HTTP2 is default.
○ Binary
○ Multiplexing
○ Flow-control
● Non-blocking, Streaming bindings
● Protobuf
○ Strict Typing
○ DTO
○ Service definitions
○ Language-agnostic
○ Auto-generated bindings for multiple languages
● Great for mobile apps
..............................................................................................
			ProtoBuff-Protocol Buffers
..............................................................................................


● IDL (interface description language) for API
● Platform neutral
● Language neutral
● Serializing/Deserializing structured data
● Very Fast / Optimized for interservices communication
● Provides client libraries automatically for many languages!
○ Java
○ C++
○ Javascript
○ Go
○ Ruby
○ C#
○ Python

.....................................................................................
					Steps to Build gRPC- api style services
.............................................................................................

1.Design Api using ProtoBuff language

2.Pick your language for writing services - java,js(node - any framework(nest))
   2.1. write service
   2.2. write servers
   2.3. clients to communicate services via server.
.....................................................................................
ProtoBuff IDL program:
......................

1.protobuff file has to be saved - serviceName.proto

2.proto is strongly typed , that means we have to specifify the type

3.Field Numbers:
  -which is used by proto interal representation to identify the fields like in REST-Json
is identified by "key": "value" - "id" : 1

 each field in the message definition has a unique number.

 These field numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. Note that field numbers in the range 1 through 15 take one byte to encode
ncluding the field number and the field's type (you can find out more about this in Protocol Buffer Encoding). Field numbers in the range 16 through 2047 take two bytes. So you should reserve the numbers 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.

The smallest field number you can specify is 1, and the largest is 229 - 1, or 536,870,911


person.proto

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32 age = 2;
}
....................................................................................
				ProtoBuff Lanaguage				
.....................................................................................
Message Fundamentals
Service Definitions

  
.....................................................................................			Complex Types-Composit Types
.....................................................................................
proto files

person.proto

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;

}
.....................................................................................
			Collecition types - repeated - arrays

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;

}
....................................................................................
.............................................................................................
					Map-Type
............................................................................................

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;
  map<string,string> values=5;

}
.....................................................................................
					Enum

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

enum Feedback {
  UNKNOWN = 0; //default value
  GOOD = 1 ;
  BAD = 2;
  VERYGOOD = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;
  map<string, string> values = 5;
  Feedback feeback = 6;

}
............................................................................................
				 Default Values
............................................................................................
int32 / any number type ->0
bool ->false
string ->empty string
enum ->first value
repeated -> empty list
map ->wrapper / empty map

.........
				Proto and Modularity
............................................................................................
			
src/main/proto/common/address.proto


syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

................................................................................
			Modualrity and Proto Buff

src/main/proto/person.proto


//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//link other proto files
import "common/address.proto";

enum Feedback {
  UNKNOWN = 0; //default value
  GOOD = 1 ;
  BAD = 2;
  VERYGOOD = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;
  map<string, string> values = 5;
  Feedback feeback = 6;

}

..........................................................................................
				Unary Service
............................................................................................

Steps:

1.define proto service definition


//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//message types
message HelloRequest{
  string name = 1;
  repeated string hobbies = 2;
}
message HelloResponse {
  string greeting = 1;
}
//service definition
service  GreetingService {
  //define rpc operation: Unary: Request-Reply - Fire and Forget -  HTTP - GET
  rpc greeting(HelloRequest) returns (HelloResponse);
}
....................................................................................

                                   Server Streaming

Use case : money withdrawal , i want to with draw money 10$ each of total 40$
					
//proto buff language version ; if dont, default version is 2
syntax = "proto3";

message  BalanceCheckRequest{
  int32 account_number = 1;
}
message Balance {
  int32 amount = 1;
}
//WithDrawRequest

message WithDrawRequest {
  int32 account_number = 1;
  int32 amount = 2;
}
//Money to be withdrawn
message Money {
  int32 money = 1;
}

//Bank service
service BankService {
  //unary
  rpc getBalance(BalanceCheckRequest) returns (Balance);
  //server streaming
  rpc withdraw(WithDrawRequest) returns(stream Money);

}
....................................................................................
			 Client Streaming
....................................................................................
                         
				
//proto buff language version ; if dont, default version is 2
syntax = "proto3";

message  BalanceCheckRequest{
  int32 account_number = 1;
}
message Balance {
  int32 amount = 1;
}
//WithDrawRequest

message WithDrawRequest {
  int32 account_number = 1;
  int32 amount = 2;
}
//Money to be withdrawn
message Money {
  int32 money = 1;
}

//Bank service
service BankService {
  //unary
  rpc getBalance(BalanceCheckRequest) returns (Balance);
  //server streaming
  rpc withdraw(stream WithDrawRequest) returns(Money);

}
....................................................................................
			BiDirectional  Streaming
....................................................................................
                         
bankservice.proto
				
//proto buff language version ; if dont, default version is 2
syntax = "proto3";
package "bank"

message  BalanceCheckRequest{
  int32 account_number = 1;
}
message Balance {
  int32 amount = 1;
}
//WithDrawRequest

message WithDrawRequest {
  int32 account_number = 1;
  int32 amount = 2;
}
//Money to be withdrawn
message Money {
  int32 money = 1;
}

//Bank service
service BankService {
  //unary
  rpc getBalance(BalanceCheckRequest) returns (Balance);
  //server streaming
  rpc withdraw(stream WithDrawRequest) returns(stream Money);

}
.....................................................................................
			 How to Build gRpc Microservices
.....................................................................................

Req:
1.proto file
2.gRpc Server
3.Deploy gRpc apps on gRpc server
4.Client apps can start communicating with grpc clients.

Steps :

1. create nest app
   nest new grpcmicroservice

2.install packages
  
  npm install @nestjs/microservices
  npm i --save @nestjs/grpc-js @grpc/proto-loader --save

3.nest-cli.json
    will have proto buff file dedection configuration.
{
  "compilerOptions": {
    "assets": [
      "**/*.proto"
    ],
    "watchAssets": true
  }
}

4.Create MicroService gRpc:
  Note: It can be hybrid app or With another app(http) 
 
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions } from '@nestjs/microservices';
import { AppModule } from './app.module';
import { grpcClientOptions } from './grpc-client.options';

async function bootstrap() {
  /**
   * This example contains a hybrid application (HTTP + gRPC)
   * You can switch to a microservice with NestFactory.createMicroservice() as follows:
   *
   * const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
   *  transport: Transport.GRPC,
   *  options: {
   *    package: 'hero',
   *    protoPath: join(__dirname, './hero/hero.proto'),
   *  }
   * });
   * await app.listen();
   *
   */
  const app = await NestFactory.create(AppModule);
  app.connectMicroservice<MicroserviceOptions>(grpcClientOptions);

  await app.startAllMicroservices();
  await app.listen(3001);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



















  





















